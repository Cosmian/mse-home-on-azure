# MSE Home on Microsoft Azure

## Create new Azure SGX VM

Create the SGX VM by replacing `${VM_NAME}`, `${GROUP}` and `${SSH_KEY}`:

```
az vm create \
	--resource-group ${GROUP} \
	--location westeurope \
	--name ${VM_NAME} \
	--size Standard_DC2s_v3 \
	--enable-secure-boot true \
	--image "canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest" \
	--public-ip-sku Standard \
	--admin-username azureuser \
	--os-disk-delete-option delete \
	--nic-delete-option delete \
	--data-disk-delete-option delete \
	--ssh-key-values ${SSH_KEY}
```

Open a new port `${PORT}` (9999 is used in the next section) if needed:

```
az vm open-port -g ${GROUP} -n ${VM_NAME} --priority 100 --port ${PORT}
```

## VM setup

Execute the ansible playbook using `${IP_ADDR}`:

```
ansible-playbook ansible/mse.yml -i "${IP_ADDR}," -u azureuser
```

## MSE example

The following section are executed on the Azure SGX VM.

### Create boilerplate application

```
mse home scaffold example
```

then edit `example/Dockerfile` and replace with the latest base image for Azure:

```
FROM ghcr.io/cosmian/mse-base-azure-beta:d3510d1b3b48b9b5402b6e60faa440d6751c33b3
```

### Encrypt and package the application

```
mse home package --code example/mse_src --dockerfile example/Dockerfile --config example/mse.toml --test example/tests/ --output code_provider --encrypt
```

then edit `example/secrets_to_seal.json` to add the encryption key `CODE_SECRET_KEY` generated by the previous command as hexadecimal string:

```
{
  "code_secret_key": "CODE_SECRET_KEY"
  ...
}
```

### Spawn your bootstrapped application

If you want to expose you service, use the external IP address `${IP_ADDR}` as Subject Alternative Name (SAN) which will be used to route the SSL traffic:

```
mse home spawn --host 0.0.0.0 --port 9999 --size 4096 --package code_provider/package_*.tar --output sgx_operator --san ${IP_ADDR} example
```

### Seal secrets with enclave's public key

```
mse home seal --input example/secrets_to_seal.json --receiver-enclave sgx_operator/ratls.pem --output code_provider/secrets_to.seal.json.enc
```

### Decrypt and run your service

```
mse home run --sealed-secrets code_provider/secrets_to.seal.json.enc --secrets example/secrets.json example
```

### Security consideration

If the network port is open you should be able to query the service:

```
$ curl -v --insecure https://${IP_ADDR}:${PORT}
```

For security reason, you have to verify the RA-TLS certificate to be sure that you are in communication with your own application.

The following command will check the attestation within server's RA-TLS certificate and check that the remote enclave runs the packaged code given as argument:

```
mse home verify --evidence sgx_operator/evidence.json --package code_provider/package_*.tar --output /tmp
```

if success, it outputs `/tmp/ratls.pem` which should be used to force HTTP client to use it as certificate authority:

```
curl -v --cacert /tmp/ratls.pem https://${IP_ADDR}:${PORT}
```

Note that you can also download the server's certificate with `openssl` if needed:

```
openssl s_client -showcerts -connect ${IP_ADDR}:${PORT} </dev/null 2>/dev/null | openssl x509 -outform PEM > /tmp/ratls.pem
```

## Delete VM

```
az vm delete --resource-group ${GROUP} --name ${VM_NAME} --yes
az network public-ip delete --resource-group ${GROUP} --name ${VM_NAME}PublicIP
az network nsg delete --resource-group GROUP --name ${VM_NAME}NSG
```
